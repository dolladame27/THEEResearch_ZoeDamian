---
title: "Evolutionary Rescue Notebook"
Autor: Damian
Date: 26.10.2025
output: html_notebook
---


## 1) Set Parameters

### comments on changes: 
N0 <- 100: we want to investigate extremely small lynx population, endangered by stochasticity, drift, fragmentation and lack of reproduction possibilities. 10000 does not fit as a "small population".

p0 <- 0.25: same here. since we start dramatically small, of course we need to scale up .

K <- 5000: According to records and literature reasonable K for metapopulation of l.pardus on iberian peninsula (where species is endemic). 

w_a <- 1.02: Original formula (mathematically) leads to constant extinction of wa due to negative intrinsic fitness.

a) extinction danger comes from fragmentation and stochasticity, so if we set w_a ~ 1, it actually has a chance to recover in higher population densities!

w_A <- 1.10: same thing here, of course its fitness needs to be increased compared to wildtype, density dependence takes care of the rest 

fa, fA <- 1.01/1.75: clear density effect for A, a has very slight crowding disadvantage (accounts for drift in homogenous populations without rescue, but still near neutral)

```{r}
## PARAMETERS
N0  <- 100   # initial total population size ###COMMENT:we want to investigate extremely small lynx pop.!

p0  <- 0.25      # initial fraction of mutants
K   <- 5000   # carrying capacity ###COMMENT:approx. literature value for l.pardus

w_a <- 1.02      # intrinsic fitness of wildtype (below 1)
w_A <- 1.10     # intrinsic fitness of mutant (above 1)

f_a <- 1.01       # density-sensitivity of wildtype
f_A <- 1.75       # density-sensitivity of mutant

tmax <- 300      # number of generations

```

## 2) Initialization of population

```{r}
Na  <- numeric(tmax)           # wildtype counts
N_A <- numeric(tmax)           # mutant counts
Na[1]  <- N0 * (1 - p0)        # initialize wildtypes




N_A[1] <- N0 * p0              # initialize mutants

```


## 3) Define fitness function: 
```{r}
fitness <- function(Ntot, w, f) {
  f_raw <- 1 + (w - 1) * (1 - f * Ntot / K)  # logistic density dependence with f
}
```

## 4) Simulation
```{r}
set.seed(1)
t_last <- 1

for (t in 2:tmax) {
  Ntot <- Na[t-1] + N_A[t-1]   # total population size in previous generation
  
  # effective fitness for each genotype
  wa_eff <- fitness(Ntot, w_a, f_a)
  wA_eff <- fitness(Ntot, w_A, f_A)
  
  # stochastic reproduction
  Na[t]  <- rpois(1, Na[t-1]  * wa_eff)
  N_A[t] <- rpois(1, N_A[t-1] * wA_eff)
  
  t_last <- t
  
  # stop if population extinct
  if ((Na[t] + N_A[t]) < 1) break
  
  # print every 10 generations
  if (t %% 10 == 0) {
    cat("Gen:", t,
        "Ntot =", Ntot,
        "wa_eff =", round(wa_eff, 4),
        "wA_eff =", round(wA_eff, 4), "\n")
  }
}
```

## 5) Plot Results
```{r}
time <- 1:t_last
plot(time, (Na + N_A)[time], type="l", lwd=2, col="black",
     ylab="Population size", xlab="Generation",
     main="Haploid Rescue with Differential Density Dependence", ylim = c(0, 5000))
lines(time, Na[time],  col="red",  lty=2)
lines(time, N_A[time], col="blue")
legend("topright", legend=c("Total","Wildtype a","Mutant A"),
       col=c("black","red","blue"), lty=c(1,2,1), bty="n")

```

## 6) Simulate Population of Wildtype a without Rescue
this loop briefly simulates what would happen if the wildtype population would be left on its own

nreps <- 1000

p_success <- p population did not fall below 100 after tmax generations (no extinction)

p_fail <- p population fell below initial population Na=100 (basically extinction)

sd <- binomial standard deviation
*plot follows*

```{r}
run_sim_a <- function() {
  Na <- numeric(tmax)
  Na[1] <- N0
  t_last <- 1
  
  for (t in 2:tmax) {
    Ntot <- Na[t-1]   # total population size in previous generation
  # effective fitness for genotype a: 
  wa_eff <- fitness(Ntot, w_a, f_a)
  Na[t]  <- rpois(1, Na[t-1]  * wa_eff)
  t_last <- t
  Nrec_a <- 100
  
  if (Na[t]>= Nrec_a) return(TRUE) #population above 100 (no decrease) -> "success"
  if (Na[t]< Nrec_a) return(FALSE) #extinction
  }
return(FALSE)                      #breaks simulation: rescue never happens
}


set.seed(1)
nrep <- 1000
results <- replicate(nrep, run_sim_a())

###evaluation of sim_a
p_success <- mean(results)
p_fail <- 1-p_success
sd <- sqrt(p_success*(1-p_success))


p_success
p_fail
sd
```

## 7) rescue probability vs p0 (initial mutant fraction)
### comments on changes: 
log(1): enables the grid to test for rescue probabilities {0,1} instead of {0,0.2}

```{r}
# parameters
p0_grid <- exp(seq(log(1/N0), log(1), length.out = 20))  #log-spaced grid, for fine resolution at small p0
nrep    <- 200                  # replicates per p0
thresh_rescue <- 0.2             # "rescued if N >= thresh*K"
set.seed(40)

# single replicate
.sim_once <- function(p0) {
  Na_i <- N0 * (1 - p0)
  NA_i <- N0 * p0
  for (t in 2:tmax) {
    Ntot <- Na_i + NA_i
    if (Ntot < 1) return(FALSE)                       # extinct
    if (Ntot >= thresh_rescue * K) return(TRUE)        # rescued
    
    wa_eff <- fitness(Ntot, w_a, f_a)
    wA_eff <- fitness(Ntot, w_A, f_A)
    
    Na_i <- rpois(1, Na_i * wa_eff)
    NA_i <- rpois(1, NA_i * wA_eff)
  }
  (Na_i + NA_i) >= thresh_rescue * K
}

# run sweep
res_stats <- do.call(rbind, lapply(p0_grid, function(p) {
  hits <- replicate(nrep, .sim_once(p))
  data.frame(p0 = p, rescue_prob = mean(hits))
}))
print(res_stats)

#plot
op <- par(no.readonly=TRUE); on.exit(par(op))
par(mar=c(4,4,1,1))
plot(res_stats$p0, res_stats$rescue_prob, log="x", ylim=c(0,1),
     type="b", pch=19, lwd=2,
     xlab=expression(p[0]~"(initial mutant fraction, log scale)"),
     ylab="Rescue probability")
P_target <- 0.9
idx <- which(res_stats$rescue_prob >= P_target)
if (length(idx) > 0) {
  p0_hit <- min(res_stats$p0[idx])
  abline(v = p0_hit, lty=2)
  mtext(sprintf("p0 ≈ %.3g reaches P≥%.2f", p0_hit, P_target),
        side=3, line=0.2)
}
```

